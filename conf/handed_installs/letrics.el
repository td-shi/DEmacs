;;; letrics.el --- simple file description

;; Copyright (C) 2017 Free Software Foundation, Inc.
;; Author: TD
;; Created: 2017-12-05
;; Version: 0.5
;; Keywords: metrics coding programming

;;; Commentary:

;;; Code:
;;;; Variables declaration
(defvar letrics-raw-contents nil "Having raw data.")
(defvar letrics-raw-lines-analyzed-file 0 "The number of lines of original state of analyzed file.")
(defvar letrics-metrics-lines-analyzed-code 0 "The number of lines of analyzed state of analyzed code.")
(defvar letrics-analyzed-all-tokens `() "Analyzed tokens.")
(defvar letrics-pointer-functions `() "Analyzed functions pointer")
(defvar letrics-functions-metrics `() "Analyzed functions.")
(defvar letrics-token-judge-regs
  `(("^||\\|^&&\\|^==\\|^\\<=\\|^\\>=\\|^!=" "BRANCH")
    ("^[\\!\\?\\<\\>]" "BRANCH")
    ("^\\+\\+\\|^\\-\\-\\|^\\*=\\|^\\+=\\|^\\-=\\|^/=\\|^=\\>" "OPERATE")
    ("^[\\+\\-\\*\\=\\%%\\.]" "OPERATE")
    ("^\\[" "SLIST")
    ("^\\]" "ELIST")
    ("^(" "SPARA")
    ("^)" "EPARA")
    ("^{" "SBLOC")
    ("^}" "EBLOC")
    ("^[0-9]+\\.?[0-9]*" "FIGUR")
    ("^[a-zA-Z_]+[a-zA-Z0-9_]*" "SYMBOL"))
  "The relational pairs of regrex and word are to judge token.")
(defvar letrics-pre-replace-regs
  `(("\\\\\\\"" "ESC")
    ("\"\\(.\\|\n\\)*?\"" "STRINGS")
    ("// ?-+LetricPassStart-+\\(.\\|\n\\)*? ?-+LetricPassEnd-+.*$" "")
    ("// ?-+LetricPassStart-+\\(.\\|\n\\)*? ?-+LetricPassEnd-+.*$" "")
    ("// ?-+LetricPassStart-+\\(.\\|\n\\)*? ?-+LetricPassEnd-+.*$" "")
    ("/\\*\\(.\\|\n\\)*?\\*/" "COMMENT")
    ("/\\*\\(.\\|\n\\)*?\\*/" "COMMENT")
    ("/\\*\\(.\\|\n\\)*?\\*/" "COMMENT")
    ("//.*$" "")
    ("\\\\.*$" "")
    ("[;:,]" " ")
    ("^\\( \\|\t\\)*" "")
    ("^#.*$" ""))
  "The relational pairs of regrex and word replace code before split tokens.")

;;;; Functions declaration.
(defun letrics-lexical-judge-token (str reg)
  "This works most bottom to judge token."
  (cond ((string-match (nth 0 (car reg)) str)
         (list (match-end 0) (nth 1 (car reg))))
        (t (letrics-lexical-judge-token str (cdr reg)))))

(defun letrics-lexical-split-tokens (str reg &optional app)
  "This function split to token from string."
  (if (not app) (setq app `()))
  (cond ((string-match "^$" str) app)
        (t (let ((point (letrics-lexical-judge-token str reg)))
                (setq app (append app (list (list (substring str 0 (nth 0 point)) (nth 1 point)))))
                (setq str (substring str (nth 0 point)))
                (letrics-lexical-split-tokens str reg app)))))

(defun letrics-analyze-each-token (blocks &optional token-list)
  "The list which contains token, attribute and apperance number of lines is generated."
  (if (not token-list) (setq token-list `()))
  (cond ((not blocks) token-list)
        (t (map `letrics-lexical-split-tokens (nth 0 (car blocks))))))

(defun letrics-split-lines-and-small-blocks (str &optional app num)
  "Code is split lines and small blocks."
  (if (not app) (setq app `()))
  (if (not num) (setq num 0))
  (cond ((not str) app)
        (t (setq app (append app (list (list (delete "" (split-string (car str))) num))))
           (letrics-split-lines-and-small-blocks (cdr str) app (1+ num)))))

(defun letrics-pre-replace (str reg)
  "Comment and literals are replaced from original code."
  (cond ((not reg) (delete "" (split-string str "\n")))
        (t (setq str (replace-regexp-in-string (nth 0 (car reg)) (nth 1 (car reg)) str))
           (letrics-pre-replace str (cdr reg)))))

(defun letrics-source-file-load (name)
  "Target source file loading."
  (with-temp-buffer (insert-file-contents name)
                    (setq letrics-target-file-raw-lines (count-lines (point-min) (point-max)))
                    (buffer-substring-no-properties (point-min) (point-max))))

(defun letrics-lines-split-tokens (str-num)
    (mapcan (lambda (x) (list (append x (list (nth 1 str-num)))))
        (mapcan (lambda (x) (letrics-lexical-split-tokens x letrics-token-judge-regs))
                (nth 0 str-num))))

(defun letrics-function-serch (letrics-tokens &optional start-position end-position app)
  (let ((current-token `())
        (current-position 0)
        (name-position 0)
        (name-flag nil)
        (para-flag nil)
        (block-start-position 0)
        (block-end-position 0)
        (max-block-nest 0)
        (counter 0))
    (if (not start-position) (setq current-position 0) (setq current-position start-position))
    (if (not end-position) (setq end-position (length letrics-tokens)))
    (if (not app) (setq app `()))
    (while (<= current-position end-position)
      (setq current-token (nth 1 (nth current-position letrics-tokens)))
      (cond ((equal current-token "SYMBOL")
             (setq name-position current-position)
             (setq name-flag t))
            ((or (equal current-token "SPARA") (equal current-token "SLIST"))
             (if (equal current-token "SPARA") (setq para-flag t) (setq para-flag nil))
             (setq counter 1)
             (while (/= 0 counter)
               (setq current-position (1+ current-position))
               (setq current-token (nth 1 (nth current-position letrics-tokens)))
               (cond ((or (equal current-token "SPARA") (equal current-token "SLIST"))
                      (setq counter (1+ counter)))
                     ((or (equal current-token "EPARA") (equal current-token "ELIST"))
                      (setq counter (1- counter))))))
            ((equal current-token "SBLOC")
             (setq current-position (1+ current-position))
             (setq current-token (nth 1 (nth current-position letrics-tokens)))
             (setq block-start-position current-position)
             (setq max-block-nest 1)
             (setq counter 1)
             (while (/= 0 counter)
               (setq current-position (1+ current-position))
               (setq current-token (nth 1 (nth current-position letrics-tokens)))
               (cond ((equal current-token "SBLOC")
                      (setq counter (1+ counter))
                      (setq max-block-nest (if (> counter max-block-nest) counter max-block-nest)))
                     ((equal current-token "EBLOC")
                      (setq counter (1- counter)))))
             (setq block-end-position current-position)
             (if (and name-flag para-flag) (setq app (append app (list (list name-position block-start-position block-end-position max-block-nest)))))
             (setq name-flag nil)
             (setq para-flag nil)
             (setq app(letrics-function-serch letrics-tokens (1+ block-start-position) (1- block-end-position) app)))
            (t
             (setq name-flag nil)
             (setq para-flag nil)))
      (setq current-position (1+ current-position)))
    app))

(defun letrics-eval-file (source-file)
  "Like Metrics Report.(verC/C++)"
  (interactive "fTarget file:")
  (with-temp-buffer
    (insert-file-contents source-file)
    (setq letrics-target-file-raw-lines (count-lines (point-min) (point-max)))
    (setq letrics-raw-contents (buffer-substring-no-properties (point-min) (point-max))))
  (letrics-evaluate letrics-raw-contents))

(defun letrics-eval-buffer (source-buffer)
  "Like Metrics Report.(VerC/C++)"
  (interactive "bTarget buffer:")
  (save-current-buffer
    (set-buffer source-buffer)
    (setq letrics-target-file-raw-lines (count-lines (point-min) (point-max)))
    (setq letrics-raw-contents (buffer-substring-no-properties (point-min) (point-max))))
  (letrics-evaluate letrics-raw-contents))

(defun letrics-metrics-function (function-pointer)
  (let ((eblcp (nth 2 function-pointer))
        (currp (nth 1 function-pointer))
        (current `())
        (current0 nil)
        (current1 nil)
        (current2 nil)
        (complex 1)
        (comment 0)
        (name (nth 0 (nth (nth 0 function-pointer) letrics-analyzed-all-tokens)))
        (sline (nth 2 (nth (nth 1 function-pointer) letrics-analyzed-all-tokens)))
        (eline (nth 2 (nth (nth 2 function-pointer) letrics-analyzed-all-tokens)))
        )
    (while (>= eblcp currp)
      (setq current (nth currp letrics-analyzed-all-tokens))
      (setq current0 (nth 0 current))
      (setq current1 (nth 1 current))
      (setq current2 (nth 2 current))
      (cond ((or (equal "if" current0) (equal "else" current0) (equal "switch" current0) (equal "case" current0) (equal "default" current0))
             (if (equal "if" (nth 0 (nth (1- currp) letrics-analyzed-all-tokens)))
                 t (setq complex (1+ complex))))
            ((equal "COMMENT" current0) (setq comment(1+ comment))))
      (setq currp (1+ currp)))
    (list(list name sline eline (- eline sline) comment complex (nth 3 function-pointer)))))

(defun letrics-report (function-metrics)
    (with-output-to-temp-buffer "letrics-temp"
      (print (format "# -*- coding:utf-8 -*-"))
      (print (format ""))
      (print (format "* ALL"))
      (print (format "  Raw Line:  %d" letrics-raw-lines-analyzed-file))
      (print (format "  Mean Line: %d" letrics-metrics-lines-analyzed-code))
      (print (format "** Funion Metrics"))
      (dolist (ons functions-metrics)
        (if (or (equal "if" (car ons))
                (equal "else" (car ons))
                (equal "for" (car ons))
                (equal "while" (car ons))
                (equal "switch" (car ons))
                (equal "do" (car ons)))
            (print (format "*** %s" (car ons)))
          (print (format "** %s" (car ons))))
        (print (format "  Start Line: %d" (nth 1 ons)))
        (print (format "  End Line:   %d" (nth 2 ons)))
        (print (format "  Mean Line:  %d" (nth 3 ons)))
        (print (format "  Nesting:    %d" (nth 5 ons)))
        (print (format "  Complex:    %d" (nth 4 ons))))
      (print (format "* End."))))

(defun letrics-evaluate (source)
  (let ((tempA nil))
    (setq tempA (letrics-pre-replace source letrics-pre-replace-regs))
    (setq tempA (letrics-split-lines-and-small-blocks tempA))
    (setq letrics-analyzed-all-tokens (mapcan #'letrics-lines-split-tokens tempA))
    (setq letrics-pointer-functions (letrics-function-serch letrics-analyzed-all-tokens))
    (setq letrics-functions-metrics (mapcan #'letrics-metrics-function letrics-pointer-functions))
    (setq letrics-metrics-lines-analyzed-code (nth 2 (reverse letrics-analyzed-all-tokens)))
    (letrics-report letrics-functions-metrics)))

(provide `letrics)
;;; letrics.el ends here
